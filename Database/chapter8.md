# 第八章 并发控制
核心
## 概述
#### 多事务执行方式
1. 事物串行执行
     - 每个时刻只有一个事物运行
     - 不能充分利用系统资源,发挥数据库共享资源的特点
2. 交叉并行方式
    - 事物的并行执行时这些并行事物的并行操作轮流交叉运行
    - 时单处理机系统中的并行方式,能够减少处理机的空闲时间,提高系统的效率
3. 同时并发方式
    - 多处理机系统中
    - 最理想的并发方式,但受制于硬件环境
    - 更复杂的并发方式机制

## 8.1 并发控制概述
- 并发控制机制的任务
    - 对并发操作进行正确调度
    - 保证事物的隔离性
    - 保证数据库的一致性

### 并发操作带来的数据不一致性
- 丢失修改
- 不可重复度
- 读脏数据

#### 1、丢失修改
丢失修改是指事物1与事物2从数据库中读入同一数据并修改,事物2的提交结果破坏了事物1提交的结果,导致事物1的修改被丢失
#### 2.不可重复读
#### 3.读脏数据

## 8.2 封锁
### 一、什么是封锁
- 封锁就是事务T在对某个数据对象(例如表,记录等)操作之前,先向系统发出请求,对其加锁
- 加锁后事务T就对该数据对象有了一定的控制,在事务T释放它的锁之前,其他事务不能更新此数据对象
- 封锁是实现并发控制的一个非常重要的技术

### 二、封锁的类型
基本封锁类型
- 排他锁(Exclusive lock,简记为X锁)
- 共享锁(Share lock,简记为S锁)

#### 排他锁
- 排他锁又称写锁
- 若事务T对数据A加上X锁,则只允许T读取和修改A,其他事务都不能再对A加任何类型的锁,直到T释放A上的锁

#### 共享锁
- 共享锁又称为读锁
- 若事物T对数据对象A加上S锁,则其它事务只能再对A加S锁,而不能加X锁,知道T释放A上的S锁

## 8.3 封锁协议
- 在运用X锁和S锁对数据对象加锁时,需要约定一些规则:封锁协议
    - 何时申请X锁或S锁
    - 持锁时间,何时释放
- 不同的封锁协议,在不同程度上为并发操作的正确调度提供了一定的保障
- 常用的封锁协议:三级封锁协议

### 1级封锁协议
- 事物T在修改数据R之前必须现对其加X锁,知道事务结束才释放(全程锁)
    - 正常结束commit
    - 非正常结束Roolback
- 读事务不加锁,写事务全程加X锁
- 1级封锁协议可以防止丢失修改
- 仍然有读脏数据和不可重复度的问题

### 2级封锁协议
- 1级封锁协议+事务T在读取数据R前必须先加S锁,读完后即可释放S锁
- 仍然由不可重复读的问题

### 3级封锁协议
- 1级封锁协议+事务T在读取数据R之前必须先对其加S锁,直到事务结束才释放

## 8.4活锁和死锁
### 一、活锁
采用先来先服务避免
### 二、死锁
- 一次封锁法
    - 一次性将所有要使用的数据全部加锁
    - 缺点:降低了并发度
- 顺序封锁法
    - 对数据对象预先规定一个封锁顺序
    - 维护成本高
    - 实现困难
- 检测死锁:超时法
    - 如果一个事务等待时间超过规定时间,就认为发生了死锁
- 等待图法
    - 用事务等待图动态反映所有事务的等待情况

## 8.5 并发调度的可串行性
- 几个事务的并行执行是正确的,***当且仅当其结果与按某一次序串行执行它们的结果相同***。这种并行调度策略称为可串行化的调度

### 保证并发操作调度正确性的方法
- 封锁方法:两断锁协议

## 8.6 两段锁协议
1. 在对任何数据进行读写操作之前,事务首先要获得对该数据的封锁
2. 在释放一个锁之后,事务不能再获得任何其他封锁  

两个阶段:
- 第一阶段是获得封锁,也称为扩展阶段
- 第二阶段是释放封锁,也称为收缩阶段

***两段锁协议是可串行化调度的充分条件***  

***一次性封锁发遵循两段锁协议***  

两断锁协议与三级封锁协议
- 目的不同
    - 两段锁协议保证并发调度的正确性
    - 三级封锁协议在不同程度上保证数据一致性
- 遵循第三级封锁协议必然遵循两端锁协议

## 8.7 封锁的粒度
### 一、什么是封锁粒度
- X锁和S锁都是加在某一个数据对象上的
- 封锁的对象:逻辑单元,物理单元
    - 逻辑单元:属性值,属性值集合,元组,关系,索引项,整个索引,整个数据库等
    - 物理单元:页,物理记录等
- 封锁对象可大可小
- 封锁对象的大小称之为封锁的粒度

#### 选择封锁的原则
以数据库/关系/元组为封锁单元

### 二、多粒度封锁
- 多粒度树
- 以树形结构来表示多级封锁粒度
- 根节点表示数据库,叶子结点表示最小的数据粒度
- 对一个结点加锁意味着对他的所有后裔结点也加以同类型的锁
- 显式封锁和隐式封锁
    - 显式封锁直接加到数据对象上的锁
    - 隐式封锁:由于上级结点加锁而使该数据对象加上了锁
    - 显隐式锁的效果一样

### 三、意向锁
加快对某个数据加锁时系统的检查效率
- 对任意结点加锁,必须先对它的上层结点加意向锁
- 如果对一个结点加意向锁,则说明该结点的下层结点正在被加锁

#### 意向共享锁(IS锁)
如果对一个数据对象加IS锁,表示它的后裔结点拟(意向)加S锁  
#### 意向排他锁(IX锁)
如果对一个数据对象加IX锁,表示它的后裔结点拟(意向)加X锁  
#### 共享意向排他锁(SIX锁)
如果对一个数据对象加SIX锁,表示对它加S锁,再加IX锁,即SIX=S+IX  
